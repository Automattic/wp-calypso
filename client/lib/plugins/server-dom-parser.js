import domSerializer from 'dom-serializer';
import * as domutils from 'domutils';
import { parseDocument } from 'htmlparser2';

/**
 * Wraps the node with methods used in then content sanitizer
 *
 * @param {object} node the node element generated by the parser.
 * @returns {object} the wrapped node element.
 */
const getNodeWrapper = ( node ) => {
	node.nodeName = node.name || '#text';

	node.parentNode = node.parent ? getNodeWrapper( node.parent ) : null;
	node.removeChild = ( child ) => {
		domutils.removeElement( child );
	};
	node.insertBefore = ( child, target ) => {
		domutils.prependChild( target.parentNode, child );
	};
	node.appendChild = ( child ) => {
		domutils.appendChild( node, child );
	};
	node.replaceChild = ( child, target ) => {
		domutils.replaceElement( target, child );
	};
	node.getAttribute = ( key ) => {
		return node.attribs[ key ];
	};
	node.setAttribute = ( key, value ) => {
		node.attribs[ key ] = value;
	};
	node.removeAttribute = ( key ) => {
		delete node.attribs[ key ];
	};
	return node;
};

/**
 * Wraps the top level node with methods used in then content sanitizer
 *
 * @param {object} body the node element generated by the parser.
 * @returns {object} the wrapped top level node element.
 */
const getBodyWrapper = ( body ) => {
	Object.defineProperty( body, 'innerHTML', {
		get: function () {
			const output = domSerializer( this, { encodeEntities: false } );
			const stippedComments = output.replace( /<!--(\n|.)*?-->/gm, '' );
			return stippedComments;
		},
	} );
	return body;
};

function* getNodeList( root ) {
	function* traverse( parent ) {
		const children = parent.childNodes || [];

		for ( let i = 0; i < children.length; i++ ) {
			yield children[ i ];
			yield* traverse( children[ i ] );
		}
	}

	for ( const node of traverse( root ) ) {
		yield node;
	}
}

class DOMDoc {
	constructor( body ) {
		this.body = getBodyWrapper( body );
	}

	createTreeWalker( body ) {
		const generator = getNodeList( body );
		return {
			currentNode: null,
			nextNode: function () {
				const { value, done } = generator.next();
				if ( done ) {
					return null;
				}
				this.currentNode = getNodeWrapper( value );
				return this.currentNode;
			},
		};
	}
}

/**
 * Server-friendly DOM parser.
 */
class DOMParser {
	parseFromString( html ) {
		return new DOMDoc( parseDocument( html ) );
	}
}

/**
 * This returns a server-friendly window-like object needed for the content sanitizer.
 */
export const getServerRoot = () => {
	return {
		DOMParser,
		document: {
			createElement: ( element ) => {
				const el = parseDocument( `<${ element }></${ element }>`, {
					encodeEntities: false,
				} ).childNodes[ 0 ];
				return getNodeWrapper( el );
			},
		},
		NodeFilter: { SHOW_ALL: 4294967295 },
	};
};

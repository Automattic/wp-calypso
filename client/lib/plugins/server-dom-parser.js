import domSerializer from 'dom-serializer';
import * as domutils from 'domutils';
import { parseDocument } from 'htmlparser2';

/**
 * Wraps the node with methods used in then content sanitizer
 *
 * @param {object} node the node element generated by the parser.
 * @returns {object} the wrapped node element.
 */
const getNodeWrapper = ( node ) => {
	node.nodeName = node.name || '#text';

	node.parentNode = node.parent ? getNodeWrapper( node.parent ) : null;
	node.removeChild = ( child ) => {
		domutils.removeElement( child );
	};
	node.insertBefore = ( child, target ) => {
		domutils.prependChild( target.parentNode, child );
	};
	node.appendChild = ( child ) => {
		domutils.appendChild( node, child );
	};
	node.replaceChild = ( child, target ) => {
		domutils.replaceElement( target, child );
	};
	node.getAttribute = ( key ) => {
		return node.attribs[ key ];
	};
	node.setAttribute = ( key, value ) => {
		node.attribs[ key ] = value;
	};
	node.removeAttribute = ( key ) => {
		delete node.attribs[ key ];
	};
	return node;
};

/**
 * Wraps the top level node with methods used in then content sanitizer
 *
 * @param {object} body the node element generated by the parser.
 * @returns {object} the wrapped top level node element.
 */
const getBodyWrapper = ( body ) => {
	Object.defineProperty( body, 'innerHTML', {
		get: function () {
			const output = domSerializer( this, { encodeEntities: false } );
			const stippedComments = output.replace( /<!--(\n|.)*?-->/gm, '' );
			return stippedComments;
		},
	} );
	return body;
};

/**
 * Generates a list of all the nodes.
 *
 * @param {object} root root element from where to travers the DOM tree.
 * @returns {Array} a list of all nodes.
 */
function getNodeList( root ) {
	let nodeList = [];

	const traverse = ( parent, visited ) => {
		if ( ! parent ) {
			return;
		}
		const children = parent.childNodes || [];

		if ( children.length ) {
			return children.forEach( ( child ) => {
				traverse( child, visited.concat( child ) );
			} );
		}
		nodeList = nodeList.concat( visited );
	};

	traverse( root, [] );
	return nodeList;
}

/**
 * Server friendly tree walking function.
 */
class TreeWalker {
	constructor( doc ) {
		this.nodes = getNodeList( doc ).map( ( node ) => getNodeWrapper( node ) );
		this.currentNodeIndex = 0;
	}

	nextNode() {
		if ( this.currentNodeIndex >= this.nodes.length ) {
			return false;
		}
		this.currentNode = this.nodes[ this.currentNodeIndex++ ];
		return this.currentNode;
	}
}

/**
 * Server-friendly parsed DOM document which can create a Tree walker.
 */
class DOMDoc {
	constructor( body ) {
		this.body = getBodyWrapper( body );
	}

	createTreeWalker( body ) {
		return new TreeWalker( body );
	}
}
/**
 * Server-friendly DOM parser.
 */
class DOMParser {
	parseFromString( html ) {
		return new DOMDoc( parseDocument( html ) );
	}
}

/**
 * This returns a server-friendly window-like object needed for the content sanitizer.
 */
export const getServerRoot = () => {
	return {
		DOMParser,
		document: {
			createElement: ( element ) => {
				const el = parseDocument( `<${ element }></${ element }>`, {
					encodeEntities: false,
				} ).childNodes[ 0 ];
				return getNodeWrapper( el );
			},
		},
		NodeFilter: { SHOW_ALL: 4294967295 },
	};
};

/**
 * External dependencies
 */
import { get } from 'lodash';

/**
 * Returns response data from an HTTP request success action if available
 *
 * @param {Object} action may contain HTTP response data
 * @returns {?*} response data if available
 */
export const getData = action => get( action, 'meta.dataLayer.data', null );

/**
 * Returns error data from an HTTP request failure action if available
 *
 * @param {Object} action may contain HTTP response error data
 * @returns {?*} error data if available
 */
export const getError = action => get( action, 'meta.dataLayer.error', null );

/**
 * @typedef {Object} ProgressData
 * @property {number} loaded number of bytes already transferred
 * @property {number} total total number of bytes to transfer
 */

/**
 * Returns progress data from an HTTP request progress action if available
 *
 * @param {Object} action may contain HTTP progress data
 * @returns {Object|null} progress data if available
 * @returns {ProgressData}
 */
export const getProgress = action => get( action, 'meta.dataLayer.progress', null );

/**
 * Dispatches to appropriate function based on HTTP request meta
 *
 * @see state/data-layer/wpcom-http/actions#fetch creates HTTP requests
 *
 * When the WPCOM HTTP data layer handles requests it will add
 * response data and errors to a meta property on the given success
 * error, and progress handling actions.
 *
 * This function accepts three functions as the initiator, success,
 * and error handlers for actions and it will call the appropriate
 * one based on the stored meta. It accepts an optional fourth
 * function which will be called for progress events on upload.
 *
 * If both error and response data is available this will call the
 * error handler in preference over the success handler, but the
 * response data will also still be available through the action meta.
 *
 * The functions should conform to the following type signatures:
 *   initiator  :: ReduxStore -> Action -> Dispatcher (middleware signature)
 *   onSuccess  :: ReduxStore -> Action -> Dispatcher -> ResponseData
 *   onError    :: ReduxStore -> Action -> Dispatcher -> ErrorData
 *   onProgress :: ReduxStore -> Action -> Dispatcher -> ProgressData
 *
 * @param {Function} initiator called if action lacks response meta; should create HTTP request
 * @param {Function} onSuccess called if the action meta includes response data
 * @param {Function} onError called if the action meta includes error data
 * @param {Function} [onProgress] called on progress events when uploading
 * @returns {?*} please ignore return values, they are undefined
 */
export const dispatchRequest = ( initiator, onSuccess, onError, onProgress = null ) => ( store, action, next ) => {
	const error = getError( action );
	if ( error ) {
		return onError( store, action, next, error );
	}

	const data = getData( action );
	if ( data ) {
		return onSuccess( store, action, next, data );
	}

	const progress = getProgress( action );
	if ( progress ) {
		return onProgress( store, action, next, progress );
	}

	return initiator( store, action, next );
};

/**
 * createWpcomHttpMiddleware makes it easier to write out new middleware handlers in a correct + concise manner.
 *
 * the general flow is as follows:
 *	1. send out the request generated by mapActionToHttp
 *	2. using both http status codes + isValidResponse determine if the response was a success/failure
 *	3. depending on success/failure, dispatch all of the appropriate actions returned by map*ResponseToActions
 *
 * Args:
 * 	type: the action type to listen for
 * 	mapActionToHttp: a function that given an action will return an WPCOM_HTTP_REQUEST action to dispatch
 * 	isValidResponse: a function that given an apiResponse will mark it as valid or invalid.
 * 									 invalid responses get sent to the error handler
 * 	mapSuccessfulResponseToActions: ( { action, apiResponse } ) => [ actions to dispatch ]
 * 	mapFailureResponseToActions: ( { action, apiResponse } ) => [ actions to dispatch ]
 */
export function createWpcomHttpMiddleware( {
	mapActionToHttp,
	isValidResponse,
	mapSuccessfulResponseToActions,
	mapFailureResponseToActions,
} ) {
	function initiator( store, action, next ) {
		store.dispatch( mapActionToHttp( action ) );
		next( action );
	}

	function onError( store, action, next, apiResponse ) {
		if ( process.env.NODE_ENV === 'development' ) {
			console.error( apiResponse ); // eslint-disable-line no-console
		}

		mapFailureResponseToActions && mapFailureResponseToActions( { apiResponse, action } )
			.forEach( store.dispatch );
	}

	function onSuccess( store, action, next, apiResponse ) {
		if ( ! isValidResponse( apiResponse ) ) {
			return onError( store, action, next );
		}

		mapSuccessfulResponseToActions && mapSuccessfulResponseToActions( { apiResponse, action } )
			.forEach( store.dispatch );
	}

	return dispatchRequest( initiator, onSuccess, onError );
}

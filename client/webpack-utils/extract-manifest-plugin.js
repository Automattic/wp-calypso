const PLUGIN_NAME = 'ExtractManifestPlugin';

class ExtractManifestPlugin {
	constructor( options = {} ) {
		this.options = {
			jsExtension: '.min.js',
			cssExtension: '.min.css',
			manifestFilename: 'manifest.js',
			runtimeChunk: 'runtime',
			globalName: '__WEBPACK_MANIFEST',
			...options,
		};
	}

	apply( compiler ) {
		// Tapping into compiler.make allow us to come after the regular TemplatedPathPlugin
		compiler.hooks.make.tap( PLUGIN_NAME, ( compilation ) => {
			let manifestContent;

			// This hook will run _after_ the default TemplatedPathPlugin, and will receive the output of
			// that default plugin as the first argument.
			//
			// This method is called several times. First, it is called to generate the filename of each chunk. In that
			// case, `data.hashWithLength` won't be defined and we just forward the output of the original TemplatedPathPlugin.
			//
			// It will also be called to generate an expression that receives a chunkId and returns the filename where that chunkId is
			// saved, something like `({1:'chunk1', 2:'chunk2'}[chunkId])+".min.js"` (simplified example). In this case, we capture the
			// manifest and store it in a separate file that will be inlined. This allows us to extract the actual runtime (i.e. webpack
			// implementaiton minus the list of chunks->files) into an external file that can be cached.
			compilation.mainTemplate.hooks.assetPath.tap( PLUGIN_NAME, ( filenameExpression, data ) => {
				// When there is no `hashWithLength`, this hook has been called to generate the file name of a chunk.
				// Return what Webpack generates unmodified.
				if ( ! data.hashWithLength || ! ( data.chunk && data.chunk.hashWithLength ) ) {
					return filenameExpression;
				}

				// If we have been called by the css-mini-extract plugin, they are asking for the manifest of files to transform a chunkId
				// into a CSS file.
				if ( data.contentHashType === 'css/mini-extract' ) {
					return `window.${ this.options.globalName }(chunkId)+"${ this.options.cssExtension }"`;
				}

				// The manifest generated by Webpack has the extension `.min.js` (as specified in output.filename). Removing it form the manifest
				// and appending it when this manifest is actually required will allow us to use the same manifest for JS and CSS files.
				const filenameExpressionWithoutExtension = filenameExpression.replace(
					this.options.jsExtension,
					''
				);

				// This is the main manifest function. It transforms a chunkId into a chink filename without the extension. Instead of rendering it
				// now, capture it and generate a new file with it.
				manifestContent = `window.${ this.options.globalName }=function(chunkId){return${ filenameExpressionWithoutExtension };}`;

				// Instead, render a call to the manifest function
				return `window.${ this.options.globalName }(chunkId)+"${ this.options.jsExtension }"`;
			} );

			// Find the `runtime` chunk and add an extra file `manifest.js`. This chunk will be composed of two files then: manifest.js contains
			// the map chunkId->file and should be inlined in the page, runtime.js contains the webpack implementation and can be loaded as an
			// external script
			compilation.hooks.additionalAssets.tap(
				{ name: PLUGIN_NAME, stage: compilation.PROCESS_ASSETS_STAGE_ADDITIONAL },
				() => {
					const manifestChunk = compilation.addChunk( this.options.runtimeChunk );
					manifestChunk.files.unshift( this.options.manifestFilename );

					compilation.assets[ this.options.manifestFilename ] = {
						source: function () {
							return manifestContent;
						},
						size: function () {
							return manifestContent.length;
						},
					};
				}
			);
		} );
	}
}

module.exports = ExtractManifestPlugin;

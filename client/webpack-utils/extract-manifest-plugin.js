const PLUGIN_NAME = 'ExtractManifestPlugin';
const { RawSource } = require( 'webpack-sources' );

class ExtractManifestPlugin {
	constructor( options = {} ) {
		this.options = {
			jsExtension: '.min.js',
			cssExtension: '.min.css',
			manifestName: 'manifest',
			runtimeChunk: 'runtime',
			globalName: '__WEBPACK_MANIFEST',
			...options,
		};
	}

	apply( compiler ) {
		// Tapping into compiler.make allow us to come after the regular TemplatedPathPlugin
		compiler.hooks.make.tap( PLUGIN_NAME, ( compilation ) => {
			let manifestContent;

			// This hook will run _after_ the default TemplatedPathPlugin, and will receive the output of
			// that default plugin as the first argument.
			//
			// This method is called several times. First, it is called to generate the filename of each chunk. In that
			// case, `data.hashWithLength` won't be defined and we just forward the output of the original TemplatedPathPlugin.
			//
			// It will also be called to generate an expression that receives a chunkId and returns the filename where that chunkId is
			// saved, something like `({1:'chunk1', 2:'chunk2'}[chunkId])+".min.js"` (simplified example). In this case, we capture the
			// manifest and store it in a separate file that will be inlined. This allows us to extract the actual runtime (i.e. webpack
			// implementaiton minus the list of chunks->files) into an external file that can be cached.
			compilation.mainTemplate.hooks.assetPath.tap( PLUGIN_NAME, ( filenameExpression, data ) => {
				// When there is no `hashWithLength`, this hook has been called to generate the file name of a chunk.
				// Return what Webpack generates unmodified.
				if ( ! data.hashWithLength || ! ( data.chunk && data.chunk.hashWithLength ) ) {
					return filenameExpression;
				}

				// If we have been called by the css-mini-extract plugin, they are asking for the manifest of files to transform a chunkId
				// into a CSS file.
				if ( data.contentHashType === 'css/mini-extract' ) {
					return `window.${ this.options.globalName }(chunkId)+"${ this.options.cssExtension }"`;
				}

				// The manifest generated by Webpack has the extension `.min.js` (as specified in output.filename). Removing it form the manifest
				// and appending it when this manifest is actually required will allow us to use the same manifest for JS and CSS files.
				const filenameExpressionWithoutExtension = filenameExpression.replace(
					this.options.jsExtension,
					''
				);

				// This is the main manifest function. It transforms a chunkId into a chink filename without the extension. Instead of rendering it
				// now, capture it and generate a new file with it.
				manifestContent = `window.${ this.options.globalName }=function(chunkId){return${ filenameExpressionWithoutExtension };};`;

				// Instead, render a call to the manifest function
				return `window.${ this.options.globalName }(chunkId)+"${ this.options.jsExtension }"`;
			} );

			// When generating the files for the `runtime` chunk, add a second file with the content of the manifest. This will reuse the filename
			// tempalte and hash for both files (eg: it will generate `runtime.<hash>.js` and `manifest.<hash>.js` and both <hash> will be the same).
			//
			// The logic has been copied from ebpack/lib/JavascriptModulesPlugin.js
			compilation.mainTemplate.hooks.renderManifest.tap( PLUGIN_NAME, ( result, options ) => {
				const { chunk, outputOptions } = options;
				const fullHash = options.fullHash;
				const useChunkHash = compilation.mainTemplate.useChunkHash( chunk );

				if ( chunk.name === this.options.runtimeChunk ) {
					// Using unshift so the manifest comes before the runtime. Only relevant for assets-writer
					result.unshift( {
						render: () => new RawSource( manifestContent ),
						filenameTemplate: chunk.filenameTemplate || outputOptions.filename,
						pathOptions: {
							contentHashType: 'javascript',
							chunk: {
								...chunk,
								name: this.options.manifestName,
							},
						},
						identifier: `chunk${ chunk.id }`,
						hash: useChunkHash ? chunk.hash : fullHash,
					} );
				}
				return result;
			} );
		} );
	}
}

module.exports = ExtractManifestPlugin;

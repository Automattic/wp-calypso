Routing
=======

Let’s start with an informal definition of a section: A _section_ is usually a subdirectory of `client/my-sites`, `client/me`, or `client/reader` (which in contrast we call _(section) groups_). Most of the sidebar’s menu items link to individual sections; and there's usually a different sidebar for each group.

Now if you’ve worked in a given Calypso section before, you’ve probably encountered a piece of code inside your section’s `index.js[x]` that reads like this:

**When writing the route definitions for a new section, don't copy this. Scroll down to the [new, recommended way](#routing-done-right).**

```js
import page from 'page';

import { siteSelection, navigation, sites } from 'my-sites/controller';
import menus from './controller';

export default function() {
	page( '/menus/:site_id', siteSelection, navigation, menus );
	page( '/menus', sites );
}
```

## Route definitions

So what we're doing here is export a default function that holds our route definitions, using the [`page.js`](https://visionmedia.github.io/page.js/) client-side router.
This pattern is the same for all Calypso sections. If you're unfamiliar with `page.js`, each of these `page` functions associate a given route (e.g. `/menus/:site_id`) with a number of functions that will be invoked when a user hits that route.

Colon-prefixed route parts (such as `:site_id` here) are called route parameters. More on them in a bit.

## Middleware

Each of the functions in a route definition is called a _middleware_, but in Calypso parlance, we like to refer to them as _controllers_, too.
Each middleware takes up to two arguments, `context` and `next`. `next` is a function that if called will just invoke the next middleware in the chain, while context is a JavaScript object whose attributes you can read and write and use to communicate information from one middleware to the next. Route params are found in `context.params` (e.g. `context.params.site_id`). The last middleware in the chain -- `menus` and `sites` in our example -- usually doesn't call `next`, since, well, it's the last middleware we're calling.

So what does each middleware do? Unsurprisingly, the last middleware is usually section-specific; and most often, it will render the section's primary content area (actually found in a `<div />` with `id="primary"`). The other middlewares found in this example are more generic (but specific to the `my-sites` group):

* `navigation` renders the section group's sidebar to the `#secondary` `<div />`.
* `siteSelection` parses the current route, looking out for something that looks like a URL or numeric site ID, and sets the currently selected site based on this information. You can then find it by using the `getSelectedSiteId` selector found in `state/sites/selectors`.
* `sites` renders a site selector menu to the `#primary` `<div />` for the user to select a site, and will then redirect to that site.

This wraps up the more introductory part; if you're interested in more details, keep on reading.

## Multi-Tree Rendering

Note that the above means that we use different middlewares to render different parts of our app. Internally, we call that _multi-tree rendering_ (MTR), and yes, it has its quirks -- we do it mostly for historic reasons.

Actually, even our `#primary` and `#secondary` `<div />`s aren't generated by the server. Instead, they're part of the [`Layout`](../client/layout/README.md) component, which is rendered even before individual sections are. (`Layout` is rendered to a `<div />` called `#wpcom`, and that _is_ server-generated.)

## Single-Tree rendering

How could multi-tree rendering -- i.e. rendering different components at different times to a React-rendered `div` -- ever work with something like [server-side rendering](server-side-rendering.md) (SSR), you might ask? Well it couldn't -- `React`'s `renderToString()` requires a single, entire component tree. So for Calypso's SSR'ed parts -- most notably the Theme Showcase -- to work, we have to resort to a different strategy; especially given that we want our JavaScript to be isomorphic, i.e. we want the same component tree to be rendered both on the server and client side.

That strategy at its center introduces a number of counterparts to the middlewares mentioned above. Instead of rendering to the  `#primary` and `#secondary` `<div />`s, they just create the respective component trees in `context.primary` and `context.secondary`. For more details, see the docs on [Isomorphic Routing](isomorphic-routing.md).

Transitioning between different single-tree rendered (STRed) sections relies on React to reconcile and update component trees, which is fine. However, transitioning between single- and multi-tree sections is rather problematic, since React will get confused by different root components and the like. As a consequence, we unfortunately have to unmount and re-render the entire app in [`client/boot`](../client/boot/index.js) when changing from an STR to an MTR section. We hope to find the time at some point to migrate all of Calypso to single-tree rendering, which would alleviate a lot of pain.

## Section Definitions

More formally, sections are defined in [`client/sections.js`](../client/sections.js) (or in the file imported from there -- `wordpress-com.js` for WordPress.com). While that file's format should be intuitive enough to understand, we use quite a bit of magic to turn it into actual routing and code-splitting code. Most of it is documented in [`server/bundler/README.md`](../server/bundler/README.md).

## Routing Done Right

For reasons outlined in the previous sections, we ask authors of new sections to write their route definitions like so:

```js
import { siteSelection, navigation, sites } from 'my-sites/controller';
import menus from './controller';

export default function( router ) {
	router( '/menus/:site_id', siteSelection, navigation, menus );
	router( '/menus', sites );
}
```

This means that instead of `import`ing `page`, you just add a `router` argument to your default-exported function which you then call like you normally would call `page`, with one difference: **Instead of `render`ing to `#primary`, make sure that your last middleware only creates its component tree in `context.primary`.** The `router` middleware arg is passed will magically render it for you. Note that this is still multi-tree rendering, but it is a bit more future-proof than otherwise.
(In case you were wondering, the `router` argument is passed to your default-exported function by the magic code found in [`server/bundler/`](../server/bundler/).)

If you're interested in single-tree rendering your section, please proceed to the [Isomorphic Routing docs](isomorphic-routing.md).

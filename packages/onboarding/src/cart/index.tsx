import config from '@automattic/calypso-config';
import { getUrlParts } from '@automattic/calypso-url';
import { NewSiteSuccessResponse, Site } from '@automattic/data-stores';
import { isBlankCanvasDesign } from '@automattic/design-picker';
import { guessTimezone, getLanguage } from '@automattic/i18n-utils';
import { setupSiteAfterCreation, isTailoredSignupFlow } from '@automattic/onboarding';
import debugFactory from 'debug';
import { getLocaleSlug } from 'i18n-calypso';
import { startsWith, isEmpty } from 'lodash';
import { getSiteTypePropertyValue } from 'calypso/lib/signup/site-type';
import wpcom from 'calypso/lib/wp';
import { cartManagerClient } from 'calypso/my-sites/checkout/cart-manager-client';
import type { DomainItem, PlanCartItem } from '@automattic/data-stores';

const Visibility = Site.Visibility;
const debug = debugFactory( 'calypso:signup:step-actions' );

export const getNewSiteParams = ( {
	dependencies,
	flowToCheck,
	isPurchasingDomainItem,
	themeSlugWithRepo,
	siteUrl,
	siteTitle,
	siteAccentColor,
	useThemeHeadstart = false,
	comingSoon,
} ) => {
	const designType = ''; //getDesignType( state ).trim();
	const siteType = ''; //getSiteType( state ).trim();
	const siteSegment = null; //getSiteTypePropertyValue( 'slug', siteType, 'id' );
	const siteTypeTheme = getSiteTypePropertyValue( 'slug', siteType, 'theme' );
	const selectedDesign = false; //get( signupDependencies, 'selectedDesign', false );

	const forceAutoGeneratedBlogName = undefined; //signupDependencies?.forceAutoGeneratedBlogName;
	const useAutoGeneratedBlogName = ! siteUrl || forceAutoGeneratedBlogName;
	// The theme can be provided in this step's dependencies,
	// the step object itself depending on if the theme is provided in a
	// query (see `getThemeSlug` in `DomainsStep`),
	// or the Signup dependency store. Defaults to site type theme.
	const theme =
		dependencies.themeSlugWithRepo ||
		themeSlugWithRepo ||
		'pub/lynx' || //get( signupDependencies, 'themeSlugWithRepo', false ) ||
		siteTypeTheme;

	// We will use the default annotation instead of theme annotation as fallback,
	// when segment and vertical values are not sent. Check pbAok1-p2#comment-834.
	const shouldUseDefaultAnnotationAsFallback = true;

	const newSiteParams = {
		blog_title: siteTitle,
		public: comingSoon ? Visibility.PublicNotIndexed : Visibility.PublicIndexed,
		options: {
			designType: designType || undefined,
			theme,
			use_theme_annotation: useThemeHeadstart,
			default_annotation_as_primary_fallback: shouldUseDefaultAnnotationAsFallback,
			site_segment: siteSegment || undefined,
			site_information: {
				title: siteTitle,
			},
			site_creation_flow: flowToCheck,
			timezone_string: guessTimezone(),
			wpcom_public_coming_soon: comingSoon,
			...( siteAccentColor && { site_accent_color: siteAccentColor } ),
		},
		validate: false,
	};

	if ( useAutoGeneratedBlogName ) {
		newSiteParams.blog_name = siteTitle; //|| getCurrentUserName( state ) || get( signupDependencies, 'username' ) || siteType;
		newSiteParams.find_available_url = true;
	} else {
		newSiteParams.blog_name = siteUrl.replace( '.wordpress.com', '' );
		newSiteParams.find_available_url = !! isPurchasingDomainItem;
	}

	if ( selectedDesign ) {
		// If there's a selected design, it means that the current flow contains the "design" step.
		newSiteParams.options.theme = `pub/${ selectedDesign.theme }`;
		newSiteParams.options.template = selectedDesign.template;
		newSiteParams.options.use_patterns = true;
		newSiteParams.options.is_blank_canvas = isBlankCanvasDesign( selectedDesign );

		if ( selectedDesign.fonts ) {
			newSiteParams.options.font_base = selectedDesign.fonts.base;
			newSiteParams.options.font_headings = selectedDesign.fonts.headings;
		}
	}

	return newSiteParams;
};

export const createSiteWithCart = async (
	flowName: string,
	isManageSiteFlow: boolean,
	userIsLoggedIn: boolean,
	shouldHideFreePlan: boolean,
	domainItem: DomainItem,
	isPurchasingDomainItem: boolean,
	themeSlugWithRepo: string,
	comingSoon: 1 | 0,
	siteTitle: string,
	siteAccentColor: string,
	useThemeHeadstart: boolean,
	themeItem = null
) => {
	const dependencies = {
		isManageSiteFlow,
		shouldHideFreePlan,
	};
	const siteUrl = domainItem.meta;

	const newCartItems = [ domainItem ].filter( ( item ) => item );
	const isFreeThemePreselected = startsWith( themeSlugWithRepo, 'pub' );
	// x	const bearerToken = get( getSignupDependencyStore( state ), 'bearer_token', null );

	if ( isManageSiteFlow ) {
		//TODO: STILL TO FIX
		const siteSlugManaged = 'dsffdsfsdfsdfsdfsd.wordpress.com'; //get( getSignupDependencyStore( state ), 'siteSlug', undefined );
		const siteId = 210841991; //getSiteId( state, siteSlug );
		const providedDependencies = { domainItem, siteId, siteUrl };
		addDomainToCart(
			dependencies,
			domainItem,
			siteSlugManaged,
			providedDependencies,
			userIsLoggedIn
		);
		return;
	}

	const newSiteParams = getNewSiteParams( {
		dependencies,
		flowToCheck: flowName,
		isPurchasingDomainItem,
		themeSlugWithRepo,
		siteUrl,
		siteTitle,
		siteAccentColor,
		useThemeHeadstart,
		comingSoon,
	} );

	// if ( isEmpty( bearerToken ) && 'onboarding-registrationless' === flowToCheck ) {
	// 	saveToLocalStorageAndProceed( state, domainItem, themeItem, newSiteParams, callback );
	// 	return;
	// }

	const locale = getLocaleSlug();

	const siteCreationResponse: NewSiteSuccessResponse = await wpcom.req.post( '/sites/new', {
		...newSiteParams,
		locale,
		lang_id: getLanguage( locale as string )?.value,
		client_id: config( 'wpcom_signup_id' ),
		client_secret: config( 'wpcom_signup_key' ),
	} );

	if ( ! siteCreationResponse.success ) {
		// TODO ebuccelli: Manage siteCreationResponse.errors
		return;
	}

	const parsedBlogURL = getUrlParts( siteCreationResponse?.blog_details.url );
	const siteSlug = parsedBlogURL.hostname;
	const siteId = siteCreationResponse?.blog_details.blogid;
	const providedDependencies = {
		siteId,
		siteSlug,
		domainItem,
		themeItem,
	};

	if ( isTailoredSignupFlow( flowName ) ) {
		await setupSiteAfterCreation( { siteId, flowName: flowName } );
	}

	await processItemCart(
		newCartItems,
		siteSlug,
		isFreeThemePreselected,
		themeSlugWithRepo,
		flowName,
		userIsLoggedIn
	);

	return providedDependencies;
};

export function addDomainToCart(
	dependencies,
	domainItem,
	siteSlug,
	stepProvidedDependencies,
	userIsLoggedIn
) {
	const slug = siteSlug || dependencies.siteSlug;
	const providedDependencies = stepProvidedDependencies || { domainItem };

	const newCartItems = [ domainItem ].filter( ( item ) => item );

	processItemCart( newCartItems, slug, null, null, null, userIsLoggedIn );
}

function prepareItemForAddingToCart( item, lastKnownFlow = null ) {
	return {
		...item,
		extra: {
			...item.extra,
			context: 'signup',
			...( lastKnownFlow && { signup_flow: lastKnownFlow } ),
		},
	};
}

export async function addPlanToCart(
	siteSlug: string,
	cartItem: PlanCartItem,
	flowName: string,
	userIsLoggedIn: boolean,
	themeSlugWithRepo: string
) {
	if ( isEmpty( cartItem ) ) {
		// the user selected the free plan
		return;
	}

	const isFreeThemePreselected = startsWith( themeSlugWithRepo, 'pub' );
	const newCartItems = [ cartItem ].filter( ( item ) => item );

	await processItemCart(
		newCartItems,
		siteSlug,
		isFreeThemePreselected,
		themeSlugWithRepo,
		flowName,
		userIsLoggedIn
	);
}

const addToCartAndProceed = async ( newCartItems, siteSlug, flowName ) => {
	const newCartItemsToAdd = newCartItems
		// .map( ( item ) => addPrivacyProtectionIfSupported( item, reduxState ) )
		.map( ( item ) => prepareItemForAddingToCart( item, flowName ) );

	if ( newCartItemsToAdd.length ) {
		debug( 'adding products to cart', newCartItemsToAdd );
		const cartKey = await cartManagerClient.getCartKeyForSiteSlug( siteSlug );

		try {
			const updatedCart = await cartManagerClient
				.forCartKey( cartKey )
				.actions.addProductsToCart( newCartItemsToAdd );

			debug( 'product add request complete', updatedCart );
		} catch ( error ) {
			debug( 'product add request had an error', error );
			//TODO Manage error
			// reduxStore.dispatch( errorNotice( error.message ) );
		}
	} else {
		debug( 'no cart items to add' );
	}
};

export async function setThemeOnSite( siteSlug: string, themeSlugWithRepo: string ) {
	if ( isEmpty( themeSlugWithRepo ) ) {
		return;
	}

	const theme = themeSlugWithRepo.split( '/' )[ 1 ];

	try {
		await wpcom.req.post( `/sites/${ siteSlug }/themes/mine`, { theme } );
	} catch ( error ) {
		//TODO: Manage error
	}
}

async function processItemCart(
	newCartItems,
	siteSlug,
	isFreeThemePreselected,
	themeSlugWithRepo,
	lastKnownFlow,
	userIsLoggedIn
) {
	if ( ! userIsLoggedIn && isFreeThemePreselected ) {
		await setThemeOnSite( siteSlug, themeSlugWithRepo );
		await addToCartAndProceed( newCartItems, siteSlug, lastKnownFlow );
	} else if ( userIsLoggedIn && isFreeThemePreselected ) {
		// fetchSitesAndUser(
		// 	siteSlug,
		// 	setThemeOnSite.bind( null, addToCartAndProceed, { siteSlug, themeSlugWithRepo } ),
		// 	reduxStore
		// );
		await setThemeOnSite( siteSlug, themeSlugWithRepo );
		await addToCartAndProceed( newCartItems, siteSlug, lastKnownFlow );
	} else if ( userIsLoggedIn && siteSlug ) {
		//fetchSitesAndUser( siteSlug, addToCartAndProceed, window.reduxStore );
		await addToCartAndProceed( newCartItems, siteSlug, lastKnownFlow );
	} else {
		await addToCartAndProceed( newCartItems, siteSlug, lastKnownFlow );
	}
}
